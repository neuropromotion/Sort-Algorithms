/* Сортировка слиянием (merge sort) (Нисходящий вариант)
Сортировка слиянием во многом похожа на быструю сортировку. Производительность сортировки слиянием лежит между пирамидальной сортировкой
и быстрой сортировкой. Но в отличае от своих соседей по производительности, данный метод более стабилен , поскольку не зависит от перестановок
элементов в массиве. 
Основное достоинство данного метода заключается в том что он идеально подходит для сортировки данных с последовательным доступом (файлы, списки, потоки), 
потому что для сортировки слиянием требуется сравнение двух элементов. Этот метод используется для внешней сортировки.
Минусом метода является расходуемая память, равная N (размер сортируемого файла).
Сложность сортировки статична и равна N * log_2 N
Реализация метода нисходящей сортировки слиянием заключается в рекурсивном разбиении исходного массива на половины, пока не получим последовательности
по 1 элементу. Потом методом слияния образуем упорядоченные двойки, четверки и тд.
*/
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
void mergesort(int * arr, int begin, int end);
int main (void)
{  
    int arr [] = {5, 6, 23, 43, 2, 1, 66, 4, 34, 0, -2, -666, 666, 102, 233, 421, 2, 66};
    int size = sizeof(arr)/sizeof(int); 
    puts("Array before merge sort:");
    for (int i = 0; i < size; i++)
        printf("%d)%d\n", i + 1, arr[i]);
    mergesort(arr, 0, size - 1);
    puts("Array after merge sort:");
    for (int i = 0; i < size; i++)
        printf("%d)%d\n", i + 1, arr[i]);
    return 0;
} 
void mergesort(int * arr, int begin, int end)
{
    if (begin == end)
        return; // границы сомкнулись
    int mid = (begin + end) / 2; // определяем середину
    mergesort(arr, begin, mid);
    mergesort(arr, mid + 1, end);
    int i = begin; // начало первого пути
    int j = mid + 1;// начало второго пути
    int * tmp = (int*)malloc(end * sizeof(int)); //массив-буфер для слияние двух отсортированных потоков
    for (int step = 0; step < end - begin + 1; step++) //
    {
        // записываем в формируемую последовательность меньший из элементов двух путей
        // или остаток первого пути если j > r
        if ((j > end) || ((i <= mid) && (arr[i] < arr[j]))) 
        {
            tmp[step] = arr[i];
            i++;
        } else 
        {
            tmp[step] = arr[j];
            j++;
        }
    }
    for (int step = 0; step < end - begin + 1; step++)
    {
        arr [begin + step] = tmp [step];
    }
    free(tmp);
}