/*Сортировка Шелла (Shell's sort)
Это модернизация сортировки вставками от Дональда Шелла (1959г). В первой итерации сортируются вставками элементы находящиеся на определенном отдаленнии 
друг от друга (это расстояние расчитывается отдельно). Во второй итерации это расстояние сокращается и происходит повторная сортировка вставками.
Таким образом массив постоянно упорядочивается, при последней итерации происходит обычная сортировка вставками целого массива, но уже по частично
отсортированному массиву, что сильно сокращает время.
Промежутки между элементами: сам Шелл предложил сначала взять промежуток равный половине размера массива и уменьшать его вдвое пока промежуток не будет
равен 1 (обычная сортировка вставками). Но такой подход оказался не оптимальным. 
Потом появился алгоритм Седжвика для выбора размера промежутка, который ускорил сортировку Шелла в разы.
четный проход: d = (9 * 2^i) - (9 * 2^(i/2)) + 1;
нечетный проход: d = (8 * 2^i) - (6 * 2^((i+1)/2)) + 1;
где d - размер промежутка (не должет быть больше чем треть сортируемого массива), i - номер прохода (1,3,5.. - для нечетной; 0,2,4.. для четной формулы)
Сложность: в лучшем случае O(n), в среднем и худшем случаях может достигать O(n^2) - зависит от выбранного шага.
*/
#include <stdio.h> 
#include <stdlib.h>
#include <time.h>
#define ARR_SIZE 50
#define RANGE 1000
#define DELIMITER "*********************"
void sort (int * arr, int sz);
int increment (int * interval, int size);
int main (void)
{   
    clock_t t;
    int arr [ARR_SIZE]; 
    srand(time(0));
    puts(DELIMITER);
    for (int i = 0; i < ARR_SIZE; i++) {arr[i] = rand() % RANGE;} // заполняем массив случайными элементами
    puts("Array before sort:\n");
    for (int i = 0; i < ARR_SIZE; i++) {printf("Element %d = [%d]\n", i + 1, arr[i]);} // выводим неотсортированный массив элементов
    puts(DELIMITER); 
    t = clock(); // получаем время перед вызовом функции сортировки Шелла
    sort (arr, ARR_SIZE); 
    t = clock() - t; // получаем время за которое произошла сортировка
    puts("Array after sort:\n");
    for (int i = 0; i < ARR_SIZE; i++) {printf("Element %d = [%d]\n", i + 1, arr[i]);} // выводим отсортированный массив
    printf("Time: %f\n", (float)t/CLOCKS_PER_SEC); //выводим время за которое массив отсортировался
    return 0;
} 

void sort (int * arr, int sz)
{
    int interval; // интервал между сортируемыми элементами, который будет постоянно уменьшаться
    int j; // индекс внутреннего цикла
    int interval_arr [50]; // массив интервалов для каждого из проходов. Проще заранее их высчитать и присваивать переменной interval 
    int counter; // номер прохода, будет индексом массива со значением релевантным соответствующему проходу
    counter = increment (interval_arr, sz); // counter получает номер последнего подходящего для нас интервала. Это удобно, т.к 
    //сортировка начинается самого большого прохода, постоянно уменьшаясь
    while (counter >= 0) // 0 проход - последний, это простая сортировка вставками
    {
        interval = interval_arr[counter--]; //interval получает значение расстояние между сортируемыми элементами из массива заполненного ф-ей increment
        for (int i = interval; i < sz; i++) // внешний цикл проходит через весь массив 
        {
            int temp = arr[i]; // 
            for (j = i - interval; (j >= 0) && (arr[j] > temp); j -= interval)
            {
                arr[j + interval] = arr[j];
            }
            arr[j + interval] = temp;
        }
    }
}

int increment (int * interval, int size)
{
/* первые три переменные это двойки со степенью i из формулы Седживика. Формула Седживика:
четный проход: d = (9 * 2^i) - (9 * 2^(i/2)) + 1;
нечетный проход: d = (8 * 2^i) - (6 * 2^((i+1)/2)) + 1;  
multiplier1 - это 2 в степени i. Общий первый множитель для четной и нечетной формул
multiplier2 - это 2 в степени ((i + 1) делить на 2). Второй множитель для нечетной формулы
multiplier3 - это 2 в степени (i делить на 2). Второй множитель для четной формулы
*/
    int multiplier1 = 1;
    int multiplier2 = 1;
    int multiplier3 = 1;
    int counter = -1; // проход. Он сразу нечетный, поскольку мы его префиксно инкрементируем и он станет 0.

    do 
    {
        if (++counter % 2) // проверка на то четный это проход или нет. первая итерация даст counter == 0, что привет к выполнению кода else (четный проход)
        {
            multiplier2 *= 2; 
            interval[counter] = ((8 * multiplier1) - (6 * multiplier2)) + 1; //вычисление интервала
        } else
        {
            interval[counter] = ((9 * multiplier1) - (9 * multiplier3)) + 1;
            multiplier3 *= 2;
        }
        multiplier1 *= 2; // первый множитель увеличивается чаще чем 2 и 3.
    } while ((3 * interval[counter]) < size); // массив заполняется пока вычисленное значение меньше трети размера массива, и останавливается тогда когда
    // значение станет больше трети массива (максимальный интервал с которого начнется сортировка вставками, постоянно уменьшаясь)
    return ((counter > 0) ? (--counter) : (0)); //возвращаются количество необходимых итераций. А массив (interval) заполнен размером интервалов
}