/* Быстрая сортировка (quick sort) 
Быстрая сортировка названа так поскольку имеет крайне высокую скорость в лучшем случае (O(n)) (в среднем О(log_2n) а в худшем O(n^2)).
Суть состоит в выборе некоторого элемента из массива, называемым разрешающим. Затем он перемещается в то место массива, где ему следует быть после 
упорядочивания всех элементов. В процессе поиска места для разрешающего элемента, в массиве происходят перестановки элементов, таким образом, что бы
слева от массива были элементы меньше его а справа больше (если мы сортируем по возрастанию). Далее алгорит вызывается рекурсивно для сортировки 
подмассива справа и слева от разрешающего элемента.
Ключеным моментом быстрой сортировки является алгоритм переупорядочивания. Реализуется он следующим образом: устанавливаются два указателя, left и right,
на самый первый элемент массива и самый последний соответственно. Далее происходит сравнение этих элементов с разрешающим. Таким образом указатели
движутся друг к другу пока значения на которые они указывают меньше или больше разрешающего соответственно. Когда значение left больше разрешающего,
а right меньше - они меняются местами (left и right). Движение указателей происходит до тех пор пока они не пересекуться. После пересечения элемент right
меняется местами с разрешающим. Далее вступает в дело рекурсивный вызов для подмассивов по обе стороны от разрешающего. 
*/
#include <stdio.h>  
void QuickSort (int * arr, int left, int right);
int main (void)
{  
    int arr [] = {5, 6, 23, 43, 2, 1, 66, 4, 34, 0, -2, -666, 666, 102, 233, 421, 2, 66};
    int size = sizeof(arr)/sizeof(int); 
    puts("Array before quicksort:");
    for (int i = 0; i < size; i++)
        printf("%d)%d\n", i + 1, arr[i]);
    QuickSort(arr, 0, size - 1);
    puts("Array after quicksort:");
    for (int i = 0; i < size; i++)
        printf("%d)%d\n", i + 1, arr[i]);
    return 0;
}  

void QuickSort (int * arr, int left, int right)
{
    int pivot; // разрешающий элемент
    int l_hold = left; // запоминаем левую границу
    int r_hold = right; // и правую
    pivot = arr[left];
    while (left < right) // пока правая и левая граница не пересеклись - выполняем цикл
    {
        while ((arr[right] >= pivot) && (left < right)) 
            right--; // перемещаем правую границу левее пока значение элемента больше разрешающего и левая-правая границы не пересеклись
        if (left != right)
        {
            arr[left] = arr[right]; // перемещаем элемент right на место разрешающего
            left++; //сдвигаем левую границу вправо
        }
        while ((arr[left] <= pivot) && (left < right))
            left++; // сдвигает левую границу пока элемент left меньше чем разрешающий
        if (left != right)
        {
            arr[right] = arr[left]; // перемещаем элемент left на место right
            right--;// сдвигаем right левее
        }
    } 
    arr[left] = pivot; // ставим разрешающий элемент на место
    pivot = left; 
    left = l_hold;
    right = r_hold;
    if (left < pivot) // рекурсивно вызваем сортировку для левой и правой части массива
        QuickSort(arr, left, pivot - 1);
    if (right > pivot) 
        QuickSort(arr, pivot + 1, right);

}